<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Meta + NSE - /tech_notes/001_grep_regex_P_examples.qmd</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Meta + NSE</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.qmd" rel="" target="">
 <span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./410_bquote_example.qmd" rel="" target="">
 <span class="menu-text">410_bquote_example.qmd</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./about.qmd" rel="" target="">
 <span class="menu-text">about.qmd</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./250_quarto_cheat.qmd" rel="" target="">
 <span class="menu-text">250_quarto_cheat</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./300_tech_notes.html" rel="" target="">
 <span class="menu-text">300_tech_notes.qmd</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools ms-auto">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#section" id="toc-section" class="nav-link active" data-scroll-target="#section">——————-</a></li>
  <li><a href="#matches-word-only" id="toc-matches-word-only" class="nav-link" data-scroll-target="#matches-word-only">matches “word” only</a></li>
  <li><a href="#remark" id="toc-remark" class="nav-link" data-scroll-target="#remark">Remark:</a></li>
  <li><a href="#catdog-fails-because-backreference-matches-result-of-grouping-not-a" id="toc-catdog-fails-because-backreference-matches-result-of-grouping-not-a" class="nav-link" data-scroll-target="#catdog-fails-because-backreference-matches-result-of-grouping-not-a"><code>catdog</code> fails because backreference matches RESULT of grouping; not a</a>
  <ul class="collapse">
  <li><a href="#in-r-does-what" id="toc-in-r-does-what" class="nav-link" data-scroll-target="#in-r-does-what">In R, does what?</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">/tech_notes/001_grep_regex_P_examples.qmd</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="main-regex-file-codedocstech_notesregex.md" class="level4">
<h4 class="anchored" data-anchor-id="main-regex-file-codedocstech_notesregex.md">Main Regex file: ~/code/docs/tech_notes/REGEX.md</h4>
</section>
<section id="this-file-codedocstech_notes001_grep_regex_p_examples.qmd" class="level4">
<h4 class="anchored" data-anchor-id="this-file-codedocstech_notes001_grep_regex_p_examples.qmd">This file: ~/code/docs/tech_notes/001_grep_regex_P_examples.qmd</h4>
<p>2024-04-20</p>
<hr>
<ul>
<li><p>quarto preview <file> –to pdf # (opens in a viewer)</file></p></li>
<li><p>quarto render % ; zathura # not quite right cli</p></li>
<li><p>math mode latex, seems to work if <em>outside</em> R chunk</p>
<p>PURPOSE: COLLECT EXAMPLES of GREP and regex (-P = Perl) [not a script] USAGE:</p>
<ul>
<li>Collect as - echo “…” | grep -P “regex string” EXAMPLES:<br>
echo “hello” | grep -P “h” str = “hello” regex=“h” echo $str | grep -P $regex</li>
</ul>
<p>GOAL:</p>
<ul>
<li>Capture, document, annotate useful REGEX examples.</li>
<li>Run and test in zsh shell (simpler and easier than fussing with quarto) assertion zero-length Lookaround (2 directions)</li>
<li>lookahead</li>
<li>lookbehind Each direction comes in two flavors, positive assertion and negative assertion</li>
</ul></li>
<li><p>!so 3512471 - non-capture (?:)</p></li>
</ul>
<pre><code>

line_break="-------------------"

## match any letter that is NOT ( or )
echo "ab(cde)fg" | grep -P "[^()]"


GREP --color=always is now in the alias for grep
SEE $ZSH alias
alias grep='grep --color=always'
echo ${line_break}

str="hello"
regex="h"
echo $str | grep -E "$regex" -

#   literal dot (use quotes)
echo abc.x | echo -E '[.]'             # matches the dot (ie literal)

**greedy**
echo aZZ | grep -E Z                    # ZZ

**not** **greedy**
regex='Z$'
echo "Z" | grep -P $regex               # Z
echo "ZZ" | grep -P $regex              # Z

#### Lazy, not Greedy - NOT WORKING!    
# Find smallest pattern that repeats one or more times
# (.+?) - ? turns match into lazy (shortest match)
# ex:  xyzzyx repeats one or more
regex="^(.+?)\1+$"
echo "xyzzyxxyzzyxxyzzyx" | grep -P $regex 
REF: https://rubular.com/r/Fa10P9Q3fB
      xyzzyxxyzzyxxyzzyx

echo "bbbbbb" | grep -P $regex 
**find adjacent repeated letters**

echo "abcdd" | grep -P '([a-z])\1'
'dd'


#section{ Why PERL? (for lookbacks) }

regex='\d(?=x)'
echo "5x" | grep -E $regex

#   sees nothing
echo "5x" | grep -P $regex


\section{Explain !}

echo '\\\\' "\\\\"              expect:     \\\\ \\ 

####    complex regex
str='animal=cat,dog,cat,'
echo $str
&lt;!--
quarto compile complains this line:
regex='(?:animal)(?:=)(\w+)(,)(?:.*)\1\2'
--&gt;
echo ${regex}
echo $str | grep -P $regex
echo 'animal=dog,cat,dog,deer,dog,' | grep -P $regex

\section{Anchors are zero-length assertions}

\begin{verbatim}


### Remarks:
#   echoing ONE expression; grep does not see 4 expressions
echo "A Z AZ AAAAAAZ" | grep -P $regex

# no dice
echo "A" "Z" "AZ" "AAAAAZ" | grep -P $regex

#   works, echo several expressoins
dotfiles=("a" "b" "c")
for j in "${dotfiles[@]}"
do
    echo "${j}" 
done

#   not work with grep
dotfiles=("A" "Z" "AZ" "AAAAAZ")
for j in "${dotfiles[@]}"
do
    echo "${j}"  | grep -P $regex
done



exit



####    GREEDY and BACKTRACK
Consider the String &lt;A tasty apple&gt;   (excluding the angle brackets)
And the pattern &lt;.*apple&gt; (again exclude the angle brackets)


initially, .* portion makes the entire string, but then can't make apple
str="A tasty apple"
regex='.*apple'
echo $str | grep -P $regex
echo $str | grep -P ".*" 


#### AAA  (fix)
str="AAA"
echo $str | grep -P "A+"
echo $str | grep -P "(A)+"

echo $str | grep -P "(AA)+"
echo $str | grep -P "(A)+\1"
echo $str | grep -P "(A).\1"
echo $str | grep -P "(A)\1"

# no match!
echo $str | grep -P "(AA)+\1"

# greedy
str="AAA"
regex='A*'
echo $str | grep -P $regex

regex='A*?'
echo $str | grep -P $regex

regex='A+?'
echo $str | grep -P $regex

str='-- comment'
regex='--(?:.*\S)?'
echo $str | grep -P $regex

####    judy followed by digit (Fails)

###  This ENDS dquote&gt;
    echo "

#   Works
    echo "judy is 3" | grep -P '\d'


# new topic 
    echo "Find Judith followed somewhere by digit"

##  ALL FAIL
echo "Judith is 10 on scale of 10!"  | grep -P "Judith(?=.*?[0-9]\S)"
echo "Judith is 10 on scale of 10!"  | grep -P 'Judith(?=.*?[0-9])'
echo "'"

echo "\'"
echo "\""



regex='Judith(?=.*?[0-9])'
echo ${regex}

## FAIL
echo "Judith is 10 on scale of 10!"  | grep -P ${regex} 

echo ${line_break}
echo "Find digits"
echo "Judith is 10 on scale of 10!"  | grep -P '\d'
echo "Judith is 10 on scale of 10!"  | grep -P \d
echo "Judith is 10 on scale of 10!"  | grep -P "\d"



echo "

##  Works
echo "digit IF followed by somewhere by x"
echo "3 ....a ...a" | grep -P '\d(?=.*x)'
echo "3 ....x ...x" | grep -P '\d(?=.*x)'


##  Works
    echo ${line_break}
    echo "digit IF followed immediately by x"
    
    ##  compare:
    echo "A: 3 ....x ...x" | grep -P '\d(?=x)'
    echo "B: ....3x ...x" | grep -P '\d(?=x)'


##  WORKS
    echo ${line_break}
    echo "Match x and digits in either order; C does not match"
    echo "B works because followed by is zero width; sees x, so it meets criteria"
    echo "C does not"

    echo "A: ...x3"  | grep -P '^(?=.*x).*\d'
    echo "B: ...3x"  | grep -P '^(?=.*x).*\d'
    echo "C: ...3"  | grep -P '^(?=.*x).*\d'

echo ${line_break}
echo "to be or not to be" | grep -P '(to)(be) or not \1 \2'
echo "to be or not to be" | grep -P '(to)(be)(?:or not) \1 \2'

echo "2021-12-13" | grep -P '(\d{4})-(\d{2})'
echo "2021-12-13" | grep -P '(\d{4})-\d{2}\1'

echo "2021-12-13" | grep -P '(\d{4})-(\d{2})-(\d{2})\3' #MONTH\1'

####    trim extra space [ nothing works here]
regex='^[\t]+|[ \t]+$'
regex='^[\s]+|[\s]+$'
echo $regex

echo " abcde" | grep -P $regex
echo "abcde " | grep -P $regex

# Fails
echo " abcde " | grep -P $regex


#   X(?=Y) means X followed by Y
regex='--.*?(?=[^\r\n\S]*$)'
echo $regex
echo '--  this is a comment.' | grep -P $regex



### LOOKAROUNDS
echo ${line_break}
echo "a followed by c"
echo 'a(?=c)'
str=bacad
echo $str | grep -P 'a(?=c)'


####  Lookahead, positive or negative

##  lookahead, positive
regex='q(?=u)'
echo "quack" | grep -P $regex

#       Rmk:    grep highlights subset meets criteria or null set 

# no match
echo "qq"  | grep -P $regex


##  lookahead, negative
regex='q(?!u)'
#   match
echo "qq" | grep -P $regex

#   no match
echo "quack" | grep -P $regex




echo "bacadc"
echo ${line_break}
echo "a NOT followed by c"
echo 'a(?!c)'
str=bacad
str=bacadc
echo $str | grep -P 'a(?!c)'





####  `(?=) FIND A, followed by ...
# match
echo "AA5" | grep -P 'A(?=5)'
echo "A2BA5" | grep -P 'A(?=5)'

# not a match
echo "AB25" | grep -P 'A(?=5)'



####  `(?!) FIND A, NOT followed by ...
regex='A(?!5)'
echo "A5 AB5" | grep -P $regex

regex='A(?!5*5)'
echo "AB25" | grep -P $regex
echo "A5 A5555555555" | grep -P $regex


## not sure about this:
regex='A(?!5*3)'
echo "A5 A5555555555" | grep -P $regex

##  Remarks:
# do not do this:
regex='A(?=[^5])'
echo "AB25 AB5 A5" | grep -P $regex

# match ends in `5`, A followed by 0,1, or more not `5`
regex='A(?=[^5]*5)'
echo "AB25" | grep -P $regex


####    Lookaheads, misc examples (fix this)
#   lookaheads do NOT move ineex
#   no match
regex='A(?=5)(?=[A-Z])'
echo "A5C" | grep -P $regex

## this will match  
regex='A(?=5[A-Z])'
echo "A5C" | grep -P $regex

##  allow 1 char; match
regex='A(?=5).(?=[A-Z])'
echo "A5C" | grep -P $regex


#### passwords validation (not working) 
REF:    http://www.rexegg.com/regex-lookarounds.html#password

# insist 6-10 char  (rexegg.com) NOPE, no match
regex='(?=^\w{6,10}$)'
echo "abcdef" | grep -P $regex

regex='(?=\w{6,10}$)'

regex='(?=\w)'
echo "abcdef" | grep -P $regex

regex='(?=^\w{6,10}$)'
echo "abcdef" | grep -P $regex
regex='(?=^\w{6-10}$)'
echo "abcdef" | grep -P $regex
echo "abcdef" | grep -P $regex
echo "abcdefgh" | grep -P $regex

##  3 conseq [A-Z}

    ##  

####    FIND a st b immediately preceeds
echo ${line_break}
echo "a preceeded by by b"
reg='(?&lt;=b)a'
echo $reg
str=bacad
echo $str | grep -P '(?&lt;=b)a'


# LOOK AROUNDS : do not capture
echo " " 
reg='(?&lt;=costs)\s\d\.\d{2}'
echo "Penguin costs 2.99, and whale costs 5.99 but I only have 2.01 left"
echo "Penguin costs 2.99, and whale costs 5.99 but I only have 2.01 left" | grep -P $reg

echo " " 
reg='\w+\s(?=costs)'
echo "Penguin costs 2.99, and whale costs 5.99 but I only have 2.01 left"
echo "Penguin costs 2.99, and whale costs 5.99 but I only have 2.01 left" | grep -P $reg


# -------
## TODO
# -------
[^.] do not understand ... see:
&lt;https://rubular.com/r/dKHqlUBWGUH4CE&gt;

^(.*\.)[^.]+$
1st group, greedy
can not have 2nd . after first
abc. (ok)
abc.. (no)


^([^-]*)-(.*)#

# ----
#   TODO
# ----
\A https://rubular.com/r/wwaAwX73g4LSSI
-   What is multiline mode?
-\b words in sentence




echo ${line_break}
echo "a NOT preceeded by by b"

### R or neovim dislikes line begins with reg=  (code appears in RED)
### Making verbatim RED go away.</code></pre>
<p>reg=‘(?&lt;!b)a’</p>
<p>echo $reg str=bacad echo $str | grep -P ‘(?&lt;!b)a’</p>
<p>echo ${line_break} echo “Precendent” reg=‘((ab|d)e)’ echo $reg str=bacade echo $str | grep -P ‘((ab|d)e)’</p>
<p>echo ${line_break} echo “Alternative” reg=‘(ab|d)e’ echo $reg str=bacade echo $str | grep -P ‘(ab|d)’</p>
</section>
<section id="section" class="level1">
<h1>——————-</h1>
<p>regex=“(?=|$)” # ——————- ## Any pattern starts with digit, follwed by end of line or non-word ## Can be multiple matches in one string ## not a-zA-Z0-9, plus _ ie ‘[^_[:alnum:]]’ ## positive lookahead (ie followed by …) echo “56” grep -P ${regex}</p>
<p>regex=“()(.*)\1”</p>
<p>regex=’()(.*)\1’ echo “wordXABC” | grep -P ${regex} echo “word;word” | grep -P ${regex} echo “word;word1” | grep -P ${regex}</p>
</section>
<section id="matches-word-only" class="level1">
<h1>matches “word” only</h1>
<p>echo “word[]” | grep -P ‘()’</p>
<section id="backreference-1" class="level4">
<h4 class="anchored" data-anchor-id="backreference-1">Backreference <code>\1</code></h4>
<p>regex=‘(cat|dog)\1’ echo “catXcat” | grep -P $regex echo “catcatX” | grep -P $regex echo “catdogX” | grep -P $regex echo “cd” | grep -P ‘[cd]\1’</p>
</section>
</section>
<section id="remark" class="level1">
<h1>Remark:</h1>
</section>
<section id="catdog-fails-because-backreference-matches-result-of-grouping-not-a" class="level1">
<h1><code>catdog</code> fails because backreference matches RESULT of grouping; not a</h1>
<p>class ## ERROR, makes no sense. echo “cd” | grep -P ‘[cd]\1’</p>
<section id="in-r-does-what" class="level2">
<h2 class="anchored" data-anchor-id="in-r-does-what">In R, does what?</h2>
<p>p.5 &lt;- problems(pattern=“(\w<em>)(.</em>)\1)”)</p>
<p>``` vim: nospell</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>